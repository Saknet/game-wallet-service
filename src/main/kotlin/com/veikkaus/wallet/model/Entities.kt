package com.veikkaus.wallet.model

import jakarta.persistence.*
import java.math.BigDecimal
import java.time.Instant
import java.util.UUID

/**
 * Represents a player's wallet state in the system.
 *
 * This entity stores the **mutable** balance of the player. It is the critical resource
 * for concurrency control.
 *
 * ## Concurrency Design
 * To prevent race conditions (e.g., double spending), access to this entity
 * during transactions must be guarded by a **Pessimistic Write Lock**
 * (`SELECT ... FOR UPDATE`).
 *
 * @property id Unique identifier for the player (UUID).
 * @property name Player's display name.
 * @property balance Current wallet balance. Strictly validated to never be negative via application logic and DB constraints.
 */
@Entity
@Table(name = "player")
data class Player(
    @Id
    val id: UUID,

    @Column(nullable = false)
    val name: String,

    @Column(nullable = false, precision = 20, scale = 2)
    var balance: BigDecimal
)

/**
 * Represents an immutable audit record of a wallet transaction.
 *
 * This entity serves two critical architectural purposes:
 * 1.  **Audit Log:** A permanent, append-only history of money movement.
 * 2.  **Idempotency Guarantee:** The [transactionId] is the database
 * primary key. Attempting to insert a duplicate ID (retry) will fail
 * at the database level, preventing duplicate processing.
 *
 * ## Design Notes
 * - All fields are marked `updatable = false` to enforce immutability at the JPA level.
 * - The primary key constraint acts as the final safeguard for idempotency.
 *
 * @property transactionId Globally unique ID provided by the client (Game Engine). Acts as the idempotency key.
 * @property playerId Foreign key reference to the [Player].
 * @property type The nature of the transaction ([TransactionType.DEBIT] or [TransactionType.CREDIT]).
 * @property amount The absolute monetary value of the transaction.
 * @property balanceAfter The player's balance immediately **after** this transaction was applied.
 * @property createdAt Timestamp of when the transaction was processed (UTC). Generated by the application for testability.
 */
@Entity
@Table(name = "wallet_transaction")
data class WalletTransaction(
    @Id
    @Column(name = "transaction_id", updatable = false)
    val transactionId: UUID,

    @Column(name = "player_id", nullable = false, updatable = false)
    val playerId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, updatable = false)
    val type: TransactionType,

    @Column(nullable = false, updatable = false, precision = 20, scale = 2)
    val amount: BigDecimal,

    @Column(name = "balance_after", nullable = false, updatable = false, precision = 20, scale = 2)
    val balanceAfter: BigDecimal,

    /**
     * The timestamp is generated by the Application (`Instant.now()`) rather than the Database.
     * This makes the logic testable and independent of DB timezones.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now()
)

/**
 * Enum representing the direction of money movement.
 *
 * - [DEBIT]: Money leaving the wallet (Purchase/Bet).
 * - [CREDIT]: Money entering the wallet (Win/Deposit).
 */
enum class TransactionType { DEBIT, CREDIT }